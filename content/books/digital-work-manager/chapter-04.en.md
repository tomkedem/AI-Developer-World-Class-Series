---
title: "Chapter 4 - Persistent Instructions and Working Policy"
weight: 6
---

## **Chapter 4 - Persistent Instructions and Working Policy**

### Why Persistent Instructions Matter More Than a One-Off Prompt

A one-off prompt is written to solve a momentary need.

There is a problem, a solution is needed, you write an instruction and move on.

It works.

Sometimes it even works very well.

But it does not hold over time.

When you work with a code agent on a regular basis,

the work is no longer a collection of disconnected requests.

It is a sequence.

In this situation, ad hoc prompts create inconsistency.

One time you emphasize tests, another time you forget.

One time you insist on style, another time you let it slide because “we just wanted to try something”.

The agent does not understand that this is a temporary exception.

From its perspective, it is a pattern.

Persistent instructions create stability.

They define how work is done here, not just what is done right now.

Instead of explaining again and again:

- how to write code  
- how to test  
- and how to be careful  

everything is already known in advance.

A developer who guides work understands that the effort should not be in every single request,

but in one good definition that holds over time.

And once that happens, the work itself becomes calmer as well.

### How to Define Code Style, Tests, and Constraints

A code agent is not born with taste.

It does not know what you consider good code,

or what counts as a solution you can live with over time.

If you do not define style, it will invent one.

If you do not emphasize tests, it will treat them as a suggestion.

And if you do not set constraints, it will try to reach the “smartest” solution,

even if it does not fit the system.

Defining style, tests, and constraints does not need to be complex.

This is not a long standards document,

but a few clear principles that repeat themselves.

What readable code looks like in your context.

When tests are mandatory.

Which shortcuts are not acceptable, even if they work.

Once these principles are fixed,

the agent stops guessing and starts adapting.

A developer who guides work does not review every line,

but checks whether the change follows the rules that were defined in advance.

That is exactly the difference between exhausting review

and orderly work with a code agent.

### How to Make the Agent Behave Like a Developer on the Team

A code agent does not need to be a lone genius.

It needs to behave like a developer on an existing team.

A team developer does not write code however they feel.

They know the conventions.

They know where to ask before changing things.

And they understand that some decisions were already made in the past, even if they disagree with them.

To make an agent behave this way, you need to give it a clear role.

Not just tasks.

What is expected of it.

What a reasonable change looks like.

And when to stop and ask.

Once this is defined,

it stops trying to “show off” at every opportunity,

and starts working within the frame.

This does not make it less effective.

It makes it predictable.

And a developer who guides work prefers a predictable agent that works consistently,

over a brilliant agent that surprises every time.

### Policy Versus Improvisation

Improvisation feels efficient.

There is a problem, there is a solution, you move fast.

But when improvisation becomes a method,

it starts working against you.

A code agent learns from patterns.

If one time you skip tests “just this once”,

or deviate from style “just to move forward”,

it is not perceived as an exception.

It is perceived as an instruction.

Policy, on the other hand, creates continuity.

It says what is done here even when no one is watching.

This does not mean there is no room for improvisation at all.

It means improvisation should be conscious,

not the default.

A developer who guides work knows when to deviate,

and when to stop and say: here we work by the rules.

Once that boundary is clear,

even the exceptions become safer.

### Creating a Consistent Working Identity for the Agent

When you work with a code agent over time, something interesting happens.

It is no longer just executing tasks.

It develops a working character.

That character does not emerge on its own.

It is a direct result of the instructions, rules, and choices you repeat.

If one time you insist on tests,

and another time you skip them without explanation,

the identity that forms is inconsistency.

If, on the other hand, the agent repeatedly encounters the same boundaries,

the same expectation of quality,

and the same way decisions are made,

it starts working in a stable way.

A consistent working identity does not mean rigidity.

It means you can predict what will happen.

A developer who guides work does not want to “start from scratch” with the agent every time.

They want it to be clear, the moment you enter a project,

how work is done here.

And once that happens,

the agent stops being an external tool,

and becomes part of a familiar working process.

### An Agent Layer Inside the Development Environment

There are tools that are not meant to be “the agent”,

but to let you build the agent that fits you.

Continue.dev is an example of this approach.

Continue is a development environment extension

that allows you to connect different AI models directly to the code editor,

and control how they work through persistent settings and rules.

Unlike a single tool with predefined behavior,

there is no fixed “personality” for the agent here.

You choose:

- which model is used  
- how it receives context  
- and which rules guide it in its work  

The core idea behind Continue is separation between the tool and the policy.

The model can change.

The principles remain.

This makes Continue less of a tool,

and more of an infrastructure.

It is especially suitable for those who work on the same project over time,

and want the code agent to behave consistently:

the same style, the same boundaries, and the same working assumptions.

In an era where tools come and go,

this approach highlights an important point:

real control is not in the model itself,

but in how it is integrated into the working process.

A developer who guides work does not have to use Continue.dev,

but it is worth understanding the idea it represents.

Because it is very likely that in the future, more and more tools will work this way:

the agent changes, and a stable working policy sits above it.
