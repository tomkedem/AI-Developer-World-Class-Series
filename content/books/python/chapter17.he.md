---
title: "פרק 17 – תרגול מאוחד: בניית mini_text_analyzer"
weight: 18
---
# **פרק 17 – תרגול מאוחד: בניית mini_text_analyzer**
הגענו לרגע שבו כל הידע מתלכד לפרויקט אחד שלם.
בפרקים הקודמים למדתם את עקרונות השפה, מבני הנתונים, ניהול קבצים, לוגים, מודולריות, טיפוסים, דקורטורים, בדיקות ו-CLI.  

עכשיו נבנה מהם את **mini_text_analyzer**, פרויקט קונספטואלי קטן, אך עם מבנה וסטנדרטים של מערכת אמיתית.  

המטרה כאן אינה רק לכתוב קוד שעובד, אלא **לראות איך כל החלקים מתחברים לתמונה אחת, תהליך מלא של עיבוד טקסטים במבנה פרויקט הנדסי שלם.**
## תרגיל 1 – מבנה פרויקט ראשוני
צרו תיקייה בשם mini_text_analyzer עם מבנה תקני:
```text
mini_text_analyzer/
├── src/
│   ├── mini_text_analyzer/
│   │   ├── __init__.py
│   │   └── text_pipeline.py
├── tests/
│   └── test_pipeline.py
├── data/
│   └── sample.txt
├── requirements.txt
└── README.md
```
אתחלו סביבה וירטואלית:
```text
python -m venv .venv
source .venv/bin/activate  # (או .venv\Scripts\activate ב-Windows)
```
אתחלו גם Git:
```text
git init
echo ".venv/" > .gitignore
```
## תרגיל 2 – טוקניזציה וניקוי בסיסי (פרקים 2–4)
צרו בקובץ text_pipeline.py פונקציות normalize() ו-tokenize() על פי שלמדתם:
- ניקוי רווחים, הורדת אותיות גדולות.
- פיצול למילים בעזרת ביטוי רגולרי.  

ודאו שהן מחזירות רשימת מילים תקנית.

## תרגיל 3 – מודולים וארגון (פרק 5)
ארגנו את הפונקציות בתוך מודול נפרד text_utils.py וייבאו אותן למחלקה הראשית.
וודאו שכל מודול אחראי על פעולה אחת בלבד – מבנה נקי וברור.

## תרגיל 4 – קונפיגורציה חיצונית (פרק 7)
צרו קובץ config.json עם הגדרות ברירת מחדל (שפה, מיקום קובצי קלט ופלט).
בנו פונקציה שטוענת את ההגדרות בצורה גנרית:
```python
import json, pathlib

def load_config(path: str = "config.json") -> dict:
    return json.loads(pathlib.Path(path).read_text(encoding="utf-8"))

```
## תרגיל 5 – חריגות ולוגים מובנים (פרק 8)
הוסיפו טיפול בשגיאות עם try/except ולוגים באמצעות מודול logging:
- לוג מידע (INFO) בכל שלב.
- לוג שגיאות (ERROR) במקרה של חריגה.  

הקפידו שכל הודעה תכלול זמן, שלב ופרטים רלוונטיים.


## תרגיל 6 – OOP: מחלקת TextPipeline (פרק 9)

צרו מחלקה:
```python
class TextPipeline:
    def __init__(self, config: dict):
        self.config = config

    def clean(self, text: str) -> str:
        ...

    def stats(self, text: str) -> dict:
        ...
```
המחלקה מאחדת את כל השלבים: קריאה, ניקוי, ניתוח, וכתיבה.

## תרגיל 7 – Type hints מלאים (פרק 10)
הוסיפו **type hints** לכל פונקציה ומחלקה:
```python
def stats(self, text: str) -> dict[str, float]:
```
כך תקבלו אוטוקומפלישן מדויק ועזר למבקרים סטטיים.

## תרגיל 8 – דקורטורים למדידה (פרק 11)
הוסיפו דקורטור בשם measure_time שמודד כמה זמן נמשכה כל פעולה.
שלבו אותו על פונקציות הניקוי והסטטיסטיקה.
## תרגיל 9 – בדיקות אוטומטיות (פרק 12)
צרו בדיקות יחידה בסיסיות בקובץ tests/test_pipeline.py עם pytest:
- בדקו שטוקניזציה מחזירה רשימה.
- בדקו שפונקציית stats מחזירה מפתחות צפויים.

##  תרגיל 10 – אופטימיזציה עם Pandas (פרקים 13–14)
הוסיפו שלב שבו stats() אוספת נתונים ל-DataFrame ומחשבת ממוצעים.
ודאו שאתם משתמשים ב-pandas בצורה יעילה.

## תרגיל 11 – CLI עם Typer (פרקים 15–16)
בנו קובץ mintx.py עם פקודות:
```text
mintx clean input.txt output.txt
mintx stats output.txt
```
הקפידו על תיעוד (help--) וקודי יציאה תקינים.

## תרגיל 12 – הרכבה סופית + CI/CD
השלימו את הפרויקט:
- ודאו שכל הקוד ממודר וקריא.
- הפעילו pytest לוודא שכל הבדיקות עוברות.
- הגדירו GitHub Actions להרצת הבדיקות אוטומטית עם כל commit.

## פתרון מלא
הפתרון המלא (זמין בריפוזיטוריון GitHub המצורף) תמצאו:
קוד שלם לכל השלבים.
מבנה פרויקט הנדסי אמיתי.
דוגמה להרצת pipeline אמיתי מקובץ טקסט גולמי ועד CLI פועל.

זהו הסיום המעשי של המסע:
מ-שורה בודדת של קוד ועד מערכת שלמה, מתועדת, נבדקת, נמדדת וניתנת להרצה בכל סביבה.  

**mini_text_analyzer** הוא אולי פרויקט קטן, אבל הוא הדגם הקלאסי של איך בונים כלי הנדסי חכם בעולם ה-AI.