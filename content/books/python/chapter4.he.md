---
title: "פרק 4 – פונקציות בפייתון"
weight: 5
---

# **פרק 4 – פונקציות בפייתון**
## פונקציות כיחידת בניין קריטית
כל שפת תכנות מאפשרת לכתוב פונקציות.
אבל בפייתון, פונקציות הן הרבה יותר מסתם דרך “לא לחזור על קוד” 
הן **אבן הבניין המרכזית של כל מערכת יציבה**.  
 אם משתנים הם החומר הגולמי שלך, הפונקציות הן המכונות שמעבדות אותו.  
 
 במערכת AI אמיתית הן מה שמפריד בין בלגן של קוד ניסיוני לבין תהליך הנדסי מדויק:
כל שלב מנוקה, נמדד, מתועד, וניתן לבדיקה.  

**למה זה קריטי בפרויקטי AI**  
במערכות למידת מכונה ובינה מלאכותית,
הקוד מתמלא מהר מאוד בחזרות 
קריאות API, ניקוי נתונים, בדיקות חריגות, מדידת זמן, שמירת תוצאות.
אם לא מפרקים את כל זה לפונקציות ברורות,
הקוד הופך לארוך, שביר, וכמעט בלתי ניתן לתחזוקה.
במקום לכתוב את הכול בלולאה אחת גדולה,
אנחנו מפרקים את המערכת **ליחידות קטנות שיש להן מטרה אחת בלבד** 
פונקציות שמקבלות קלט, מבצעות פעולה מדויקת, ומחזירות תוצאה ברורה.  

זו הגישה שמאפשרת:
- לבדוק כל שלב בנפרד (Unit Testing) 
- למדוד ביצועים בצורה ממוקדת
- לכתוב קוד שאפשר להרחיב בלי לשבור
- ולעבוד בצוות בלי דריכה הדדית על רגליים  

**פונקציה טובה היא כמו מכונה**

היא צריכה שלוש תכונות:  
1. **קלט ברור**: מה היא מקבלת.  
2. **פלט צפוי**: מה היא מחזירה.  
3. **שום תופעות לוואי מיותרות**: היא לא משנה משתנים חיצוניים בלי סיבה.

היא לא חייבת להיות קצרה, אבל היא חייבת להיות ממוקדת.  
אם פונקציה עושה **גם ניקוי, גם עיבוד, גם הדפסה**, זה סימן שכדאי לחלק אותה לשלוש.

**תזכורת קטנה**  
פייתון לא מאלצת אותך לכתוב פונקציות 
אבל היא **מתגמלת אותך** כשאתה כותב אותן נכון.
קוד פונקציונלי הוא קריא יותר, קל יותר לבדיקה,
ובמערכות AI: הוא גם מאפשר לנתק רכיבים לצורך ניסויים מבלי לשבור את המערכת כולה.
במילים פשוטות:
פונקציות הן תזכורת שפיתוח טוב מתחיל בהנדסה,
לא בניסוי וטעייה.

## פרמטרים והחזרת ערכים (כולל tuple unpacking)
פונקציה היא כמו “מכונה קטנה”:  
אתה נותן לה קלט, היא עושה עיבוד, ומחזירה תוצאה.
אבל בפייתון, המכונה הזו גמישה בהרבה ממה שנראה במבט ראשון.
היא לא מחייבת אותך בהצהרות ארוכות, 
אבל מאפשרת לך לבנות מנגנון קלט ופלט מדויק, כמעט כמו במערכת טיפוסים חזקה.  

**פרמטרים בסיסיים**
```python
def greet(name):
    print(f"Hello {name}!")
```
הקריאה פשוטה:
```python
greet("Tamar")
```
מאחורי הפשטות הזו מסתתרת לא מעט עוצמה.
כשאתה מעביר ערך לפונקציה, פייתון לא יוצרת ממנו עותק חדש, היא פשוט נותנת לפונקציה גישה לאותו אובייקט בזיכרון.
אם זה אובייקט שניתן לשינוי, כמו רשימה או מילון, כל שינוי שתעשה עליו בתוך הפונקציה **ישפיע גם מחוץ לה**.
וזה מצוין כשזה מה שאתה רוצה, אבל עלול להיות כאב ראש כשלא.
כדי להימנע מהפתעות כאלה, כדאי לעבוד על **עותק חדש** כשלא רוצים “אפקט צד”. 

**החזרת ערכים**  
פונקציה מחזירה ערך בעזרת return.
אם אין return, היא מחזירה אוטומטית None.
```python
def add(a, b):
    return a + b

result = add(5, 7)
print(result)  # 12

```
אין צורך להגדיר טיפוס החזרה,
אבל מהנדסים מנוסים מוסיפים type hints כדי לשמור על סדר:
```python
def add(a: int, b: int) -> int:
    return a + b
```
**החזרת כמה ערכים יחד**  
בניגוד לשפות אחרות שדורשות מחלקה או מבנה נתונים מיוחד,
פייתון מאפשרת להחזיר מספר ערכים בבת אחת. פשוט על ידי החזרת tuple:
```python
def min_max_avg(values: list[int]) -> tuple[int, int, float]:
    return min(values), max(values), sum(values) / len(values)

```
ועכשיו אפשר לפרק את התוצאה ישירות:
```python
nums = [10, 5, 8, 12]
low, high, avg = min_max_avg(nums)
print(low, high, avg)  # 5 12 8.75

```
זה נקרא **tuple unpacking**,
וזו אחת הסיבות שפייתון כל כך קריאה 
היא מאפשרת “להוציא מידע ממבנה” בלי תחביר כבד.

**פרמטרים בעלי שם (Keyword Arguments)**  
פייתון מאפשרת גם קריאה מפורשת לפי שם,
מה שהופך את הקוד לברור יותר:
```python
def connect(host: str, port: int):
    print(f"Connecting to {host}:{port}...")

connect(port=8080, host="localhost")

```
כך אתה לא תלוי בסדר הפרמטרים,
והקוד שלך כמעט קורא את עצמו.  

**טיפ הנדסי**  
בפונקציות טובות, המידע **נכנס ברור ויוצא ברור**.
בלי הפתעות, בלי תלות במשתנים גלובליים.
העיקרון פשוט: פונקציה צריכה לדעת הכול על מה שנכנס אליה. ושום דבר על מה שקורה מחוצה לה.
במערכות AI זה קריטי: פונקציות נבדקות בנפרד, נמדדות בנפרד,
וחייבות להחזיר תוצאות צפויות גם כשהקלט משתנה.

## ערכי ברירת מחדל ו-pitfalls עם mutable defaults
פייתון מאפשרת להגדיר **ערכי ברירת מחדל** לפרמטרים,
וכך להפוך פונקציות לגמישות וידידותיות יותר:
```python
def greet(name: str, greeting: str = "Hello"):
    print(f"{greeting}, {name}!")
```
כעת אפשר לקרוא לפונקציה בשתי דרכים:
```python
greet("Tamar")           # Hello, Tamar!
greet("Noam", "Hi")      # Hi, Noam!
```
זה נוח, קריא, ומקצר המון קוד.
אבל מתחת לפני השטח מסתתרת אחת המלכודות הוותיקות והמסוכנות ביותר בשפה:
ה-**mutable default trap**.  

**המלכודת: ערכי ברירת מחדל נוצרים פעם אחת בלבד**  
פייתון מחשבת את ערכי ברירת-המחדל **רק פעם אחת, בזמן הגדרת הפונקציה**,
ולא בכל פעם שהיא נקראת.
אם הערך הוא משתנה Mutable (כמו list, dict, או set),
הוא יישמר בזיכרון בין קריאות לפונקציה.
```python
def add_item(item, items=[]):
    items.append(item)
    return items

print(add_item("A"))  # ['A']
print(add_item("B"))  # ['A', 'B']  # surprising
```
במקום להתחיל רשימה חדשה בכל קריאה,
הפונקציה משתמשת באותה רשימה מהפעם הקודמת.
זו לא “תקלה”, זה העיצוב של השפה,
אבל אם לא יודעים עליו, זה עלול ליצור באגים חמקמקים מאוד.  

**הפתרון הנכון**  
הדרך הבטוחה היא להשתמש ב-None כברירת מחדל,
וליצור את האובייקט בתוך גוף הפונקציה:
```python
def add_item(item, items=None):
    if items is None:
        items = []
    items.append(item)
    return items
```
כעת כל קריאה מתחילה עם רשימה חדשה:
```python
print(add_item("A"))  # ['A']
print(add_item("B"))  # ['B']
```
פשוט, ברור, ובטוח.  

**למה זה חשוב בפרויקטי AI?**   
במערכות AI ו-Data Processing,
פונקציות רבות בונות מבני נתונים או אוספות תוצאות בין קריאות.
אם אתה נופל במלכודת הזו,
הנתונים שלך “נוזלים” מקריאה לקריאה 
ופתאום אתה מקבל תוצאות לא צפויות בלי להבין למה.
לכן, כלל הברזל:
לעולם אל תשתמש בערך ברירת-מחדל Mutable.
תמיד העדף None ויצירה מחדש בתוך הפונקציה.  

**טיפ הנדסי**   
מפתחים מנוסים נופלים במלכודת הזו לא בגלל חוסר ידע,
אלא כי הקוד “נראה נכון”.
אבל חלק מהיותך מהנדס הוא **לזהות מצבים שנראים תמימים אך מסוכנים**.
בפייתון, זוהי אחת הדוגמאות הקלאסיות.

## ‎*args ו -‎**kwargs  מתי ואיך
פייתון מתייחסת לפונקציות כאל ישויות דינמיות.
אין חובה להגדיר מראש כמה פרמטרים הפונקציה תקבל 
אפשר לכתוב פונקציה שמקבלת **מספר משתנה של ארגומנטים**,
ולנהל אותם בצורה חכמה בתוך הגוף שלה.  

**‎*args ארגומנטים מיקומיים**  
הכוכבית היחידה * משמשת לאיסוף כל הפרמטרים **המיקומיים** (positionals) לתוך tuple.
```python
def summarize(*args):
    print(args)

summarize(1, 2, 3)
# output: (1, 2, 3)
```
כל הערכים שהועברו נכנסים ל-args כרצף (tuple). 
אפשר לעבור עליהם בלולאה, לסכום אותם, או לעבד אותם כרשימה:
```python
def add_all(*numbers):
    return sum(numbers)

print(add_all(3, 5, 10))  # 18
```
אם אתה לא יודע מראש כמה פרמטרים יגיעו, זו הדרך הבטוחה לטפל בזה.  

****kwargs ארגומנטים לפי שם**  
שתי כוכביות (**) משמשות לאיסוף פרמטרים בשם (keyword arguments).
הם נשמרים בתוך מילון (dict) כך שקל לגשת אליהם לפי שם:
```python
def describe_person(**kwargs):
    print(kwargs)

describe_person(name="Tamar", age=29, city="Tel Aviv")
# {'name': 'Tamar', 'age': 29, 'city': 'Tel Aviv'}
```
אפשר להשתמש בהם ישירות:
```python
def describe_person(**kwargs):
    for key, value in kwargs.items():
        print(f"{key}: {value}")
```
**שילוב של שניהם**  
פייתון מאפשרת לשלב בין שני הסוגים, קודם *args, אחר כך **kwargs:
```python
def debug(*args, **kwargs):
    print("ARGS:", args)
    print("KWARGS:", kwargs)

debug(10, 20, mode="test", verbose=True)

```
פלט:
```python
ARGS: (10, 20)
KWARGS: {'mode': 'test', 'verbose': True}

```
כך ניתן לכתוב פונקציות גמישות שמקבלות קלט מכל סוג 
כמו פונקציות לוג, דיבוג, או עיבוד נתונים גנרי.  

**שימוש מעשי בפרויקטי AI עם kwargs`**`**

במערכות AI הממשק משתנה כל הזמן. היום צריך שני פרמטרים, מחר מצטרפים עוד שלושה. kwargs** מאפשר לך לשמור על יציבות בקוד גם כשהממשק מתרחב.   

**שלב 1: גרסה בסיסית וגמישה**  

הפונקציה יודעת מה חשוב לה, וכל השאר נכנס דרך המילון בלי לשבור כלום.
```python
def run_inference(model, **config):
    # default values
    temperature = config.get("temperature", 0.7)
    max_tokens = config.get("max_tokens", 256)

    # use only what is needed right now
    return model.generate(temp=temperature, limit=max_tokens)

# usage example
config = {
    "temperature": 0.8,
    "max_tokens": 512,
    "top_p": 0.9,       # new field not used yet
    "logprobs": True    # another unused field
}

result = run_inference(gpt_model, **config)
print(result)
# example output:
# "The model generated a response with temperature 0.8 and a limit of 512 tokens"
```
הפונקציה משתמשת רק בפרמטרים שהיא מכירה. שדות חדשים לא שוברים שום דבר.

**שלב 2: מתקדמים בלי לשנות קריאות קיימות**  

אחרי חודש מוסיפים תמיכה ב-top_p. הקריאות נשארות זהות.
```python
def run_inference(model, **config):
    temperature = config.get("temperature", 0.7)
    max_tokens  = config.get("max_tokens", 256)
    top_p       = config.get("top_p", 1.0)  # new usage

    return model.generate(
        temp=temperature,
        limit=max_tokens,
        top_p=top_p
    )

# same call exactly as before
result = run_inference(gpt_model, **config)
print(result)
# example output:
# "The model generated a response with temp 0.8, limit 512, top_p 0.9"
```
זה כל הרעיון: מתחילים פשוט, מוסיפים יכולות כשצריך, והקוד שמסביב לא נשבר.  

**טיפ הנדסי**  
`*args` ו-`**kwargs` הם לא טריק תחבירי, הם **תבנית הנדסית** שמאפשרת להרחיב מערכות מבלי לשנות ממשקים.
אבל כמו כל גמישות, צריך לדעת היכן לעצור:
אם פונקציה משתמשת ב-kwargs לכל דבר, סימן שהיא צריכה ריפקטור.
כלל זהב: השתמש ב-`*args` ו-`**kwargs`רק כשאתה באמת צריך גמישות,
לא כדי להסתיר מבנה לא ברור של נתונים.

**פונקציות כערכים (First-Class Citizens)**  
בפייתון, פונקציות מתנהגות כמו כל משתנה אחר
אפשר לשמור אותה במשתנה, להעביר אותה כפרמטר,
להחזיר אותה כפלט, ואפילו לבנות פונקציות שמייצרות פונקציות אחרות.
זו לא סתם גמישות תחבירית, זו דרך חשיבה.
במקום להעביר רק נתונים, אתה מעביר **התנהגות**.
**פונקציה שמאוחסנת במשתנה**
```python
def greet(name: str) -> str:
    return f"Hello {name}!"

say_hi = greet
print(say_hi("Noam"))  # Hello Noam!
```
כאן say_hi הוא משתנה שמצביע לפונקציה greet.
לא בוצעה קריאה לפונקציה, רק “שימור” שלה.
זה מאפשר להעביר פונקציות בדיוק כמו שמעבירים מחרוזת או רשימה.

**פונקציה כפרמטר לפונקציה אחרת**
```python
def apply_twice(func, value):
    return func(func(value))

def add_one(x: int) -> int:
    return x + 1

print(apply_twice(add_one, 3))  # 5

```
כאן הפונקציה apply_twice מקבלת פונקציה אחרת (add_one) 
ומפעילה אותה פעמיים על הערך.
אין כאן קסם, רק ניצול של העובדה שפונקציות הן אובייקטים לכל דבר.  

**החזרת פונקציה מתוך פונקציה**  
כן, גם זה אפשרי. וזה אפילו שימושי מאוד:
```python
def make_multiplier(factor: int):
    def multiply(x: int) -> int:
        return x * factor
    return multiply

double = make_multiplier(2)
print(double(5))  # 10

```
זו פונקציה שיוצרת פונקציות.
כשקוראים ל-(2) make_multiplier היא לא מחזירה מספר, אלא **פונקציה חדשה** בשם multiply שכבר “מכירה” את הערך של factor.
כל פעם שנקרא ל-double, היא תשתמש באותו ערך שנשמר. במקרה הזה 2.
התופעה הזו נקראת **Closure**.
המשמעות היא שהפונקציה הפנימית **זוכרת** את הערכים שהיו זמינים בזמן שנוצרה, גם אחרי שהפונקציה החיצונית כבר הסתיימה.
זה שימושי במיוחד כשאתה רוצה ליצור **פונקציות מותאמות מראש** 
למשל פונקציה שמחשבת מחיר עם מע״מ, מקדם הנחה, או כל קבוע אחר:
```python
add_vat = make_multiplier(1.17)
discount = make_multiplier(0.9)

print(add_vat(100))   # 117.0
print(discount(200))  # 180.0
```
כל אחת מהן “זוכרת” את המקדם שלה,
וזה מה שהופך את ה-Closure לכלי כל כך אלגנטי לבניית לוגיקה חכמה ופשוטה.

**למה זה חשוב בפרויקטי AI**  
במערכות AI אנחנו מריצים קוד שחוזר על עצמו 
ניקוי טקסט, מדידה, לוגים, עיבוד פלטים, ועוד.
כשפונקציות הן אובייקטים, אפשר לבנות **תהליכים גנריים**,
שמקבלים “התנהגות” כפרמטר, בלי לשכפל לוגיקה.
```python
def process_text(text: str, transform):
    clean = text.strip().lower()
    return transform(clean)

result = process_text("  AI IS AMAZING  ", lambda t: t.replace("ai", "ML"))
print(result)  # ml is amazing

```
כך פונקציה אחת יכולה לטפל בכל תרחיש 
רק מחליפים את ההתנהגות שמועברת לה.


**טיפ הנדסי**  
במערכות בוגרות, פונקציות אינן רק “פעולות”, הן **ממשקים קטנים**.
היכולת להעביר, לשמור ולהחזיר פונקציות
מאפשרת לבנות מערכות מודולריות, עם אחריות ברורה ויכולת הרחבה אינסופית.
פייתון נותנת לך את זה ישר מהקופסה 
והיא עושה את זה בפשטות שמרבית השפות הוותיקות עדיין מקנאות בה.

##  lambda פונקציות אנונימיות ושימוש עם map/filter
עד עכשיו כל פונקציה שהגדרנו קיבלה שם.
אבל לפעמים אתה צריך פונקציה קטנה, רגעית 
כזו שנועדה לפעולה אחת בלבד,
ואין סיבה "להכביד" עליה בהגדרה מלאה.
כאן נכנסת לתמונה המילה הקטנה **lambda** 
פונקציה אנונימית (כלומר בלי שם),
שאפשר להגדיר במקום שבו היא נדרשת.  

**התחביר**  

lambda פרמטרים: ביטוי

הביטוי היחיד שאחרי הנקודתיים הוא מה שהפונקציה מחזירה.
אין צורך במילת מפתח return.  

לדוגמה:
```python
square = lambda x: x ** 2
print(square(5))  # comment
```
זה שווה ערך לכתיבה:
```python
def square(x):
    return x ** 2
```
אבל הרבה יותר קצרה כשמדובר בפעולה פשוטה.  

**שימושים קלאסיים**  

פונקציות lambda הופכות לחזקות במיוחד כשהן משולבות עם כלים כמו map, filter, ו-sorted 
פונקציות שמקבלות פונקציה אחרת כפרמטר.
```python
numbers = [1, 2, 3, 4, 5]

# square all numbers
squares = list(map(lambda x: x ** 2, numbers))

# filter even numbers
evens = list(filter(lambda x: x % 2 == 0, numbers))

print(squares)  # [1, 4, 9, 16, 25]
print(evens)    # [2, 4]
```
במקום להגדיר פונקציה חיצונית בשם,
אנחנו פשוט “שולפים” פונקציה קטנה לתוך השורה.  

**שימוש עם sorted**  
פייתון מאפשרת גם למיין לפי ביטוי מסוים באמצעות key:
```python
words = ["AI", "python", "Machine", "deep"]
words.sort(key=lambda w: len(w))
print(words)  # ['AI', 'deep', 'python', 'Machine']
```
ה- lambda כאן משמשת כתנאי מיון זמני,
בלי להגדיר פונקציה נפרדת.

**למה זה חשוב בפרויקטי AI**  
כשאתה עובד עם נתונים, מודלים או preprocessing,
יש אינספור מצבים שבהם אתה צריך פונקציה רגעית:
להמיר טקסטים, לנקות נתונים, לסנן תוצאות.
lambda מאפשרת לכתוב את זה **ישירות בהקשר** 
כך שהקוד נשאר קומפקטי וברור.  

לדוגמה:
```python
texts = [" AI ", "Data ", " science  "]
cleaned = list(map(lambda t: t.strip().lower(), texts))
print(cleaned)  # ['ai', 'data', 'science']
```
זו בדיוק הגישה הפייתונית: לא לפזר פונקציות מיותרות, אלא לכתוב רק מה שצריך.   

**טיפ הנדסי**  
למרות הפיתוי, אל תשתמש ב- lambda כדי לכתוב לוגיקה מורכבת.
היא נועדה לפעולות קצרות וברורות בלבד.
כלל אצבע פשוט:
אם הפונקציה שלך לא נכנסת לשורה אחת, תן לה שם אמיתי.
lambda היא כמו ביטוי רגולרי: נהדרת כשמשתמשים בה במידה.


## Scope: LEGB (Local, Enclosing, Global, Built-in)

בכל פעם שפייתון רואה שם של משתנה,
היא צריכה לדעת מאיפה להביא את הערך שלו.
האם הוא הוגדר בתוך הפונקציה? מחוצה לה? אולי בכלל מילה שמורה של השפה?
כדי להחליט, פייתון עוברת בסדר קבוע עם 
מנגנון חיפוש שנקרא **LEGB**:  
**L – Local** (בתוך הפונקציה)  
**E – Enclosing** (בתוך פונקציה עוטפת)  
**G – Global**  (ברמה הגלובלית של הקובץ)  
**B - Built-in** (הגדרות של פייתון עצמה, כמו len או print)  

**Local - תחום מקומי** 

זהו התחום הצר ביותר, משתנים שהוגדרו **בתוך** **פונקציה**.
```python
def show():
    msg = "Hello"
    return msg

# function call
print(show())  # Hello
```
**הסבר קצר:**  
הפונקציה show() **לא** מדפיסה בעצמה, אלא מחזירה את הערך "Hello".
הקריאה ל-print(show()) מדפיסה את מה שהפונקציה החזירה.
זו דרך נקייה וברורה יותר לכתוב פונקציות.
הן עושות חישוב ומחזירות תוצאה,
וההדפסה מתבצעת רק מחוץ להן.

**Enclosing - תחום עוטף**  
כשיש פונקציות בתוך פונקציות,
הפונקציה הפנימית יכולה לגשת למשתנים של הפונקציה העוטפת.
```python
def outer():
    name = "Tamar"

    def inner():
        return "Hello " + name

    return inner()

# function call
print(outer())  # Hello Tamar
```
הפונקציה inner() לא מגדירה את name בעצמה,
אלא משתמשת בערך שהוגדר ב-scope העוטף שלה (outer).

**Global - משתנים גלובליים**  
אם המשתנה לא נמצא לא בתחום המקומי (Local) ולא בתחום העוטף (Enclosing), פייתון תבדוק אם הוא הוגדר ברמה הגלובלית של הקובץ.

```python
count = 0

def increment():
    global count
    count += 1

# function call
increment()
print(count)  # 1
```
המילה global אומרת לפייתון:
“אל תיצור משתנה חדש מקומי, השתמש בזה שמוגדר מחוץ לפונקציה.”

**Built-in  משתנים פנימיים של השפה**  
אם פייתון לא מוצאת את המשתנה באף אחד מהשלבים הקודמים,
היא בודקת האם זהו שם שמובנה בשפה עצמה:
```python
print(len("AI"))  # len is a built in function
```
מילים כמו len, sum, range, ו-print
הן חלק מה-Built-ins של פייתון.
אפשר “לדרוס” אותן בטעות, ולכן כדאי להימנע משמות כאלה בקוד שלך:
הנה התרגום לאנגלית, בלי מקפים בתוך הטקסט ועם שמירה על המשמעות:

```python
sum = 42  # the original sum function is no longer available
```


**דוגמה שמאחדת הכול**
```python
x = "global"

def outer():
    x = "enclosing"
    def inner():
        x = "local"
        print(x)
    inner()

outer()
```
פלט:
```text
local
```
אם נמחוק את ההגדרה המקומית (x = "local"),
פייתון תשתמש בזה מה-Enclosing.
אם גם זה לא קיים, היא תעבור ל-Global,
ואם גם שם לא תמצא, תבדוק ב-Built-ins.
זו בדיוק שרשרת ה-LEGB.  

**טיפ הנדסי**  
הבנת Scope היא קריטית כשכותבים מערכות מורכבות 
במיוחד ב-AI, שם קוד רץ במקביל, בפונקציות פנימיות וב-callbacks.
זכור את הכלל הזה:
“השתמש בערכים מקומיים, העבר משתנים גלובליים כפרמטרים,
ואל תיגע בפונקציות או באובייקטים מובנים (Built-ins), אלא אם אתה באמת יודע מה אתה עושה.”  

Scope ברור = קוד צפוי = פחות באגים.

## Docstrings תיעוד קוד מקצועי
כל מתכנת יודע שצריך “להשאיר הערות בקוד”,
אבל מתכנתים מצוינים יודעים שצריך **לתעד את ההתנהגות, לא את התחביר**. 
כאן נכנסים לתמונה **Docstrings**
תיעוד מובנה שמאפשר להבין מה הפונקציה עושה,
איך משתמשים בה, ומה היא מחזירה 
ישירות מהקוד, בלי לפתוח קובץ נפרד.  

**מה זה Docstring?** 

Docstring הוא מחרוזת טקסט שנמצאת מיד אחרי הגדרת פונקציה, מחלקה או מודול.
הוא כתוב בין שלושה גרשיים (""") ומשמש כפירוט רשמי לתיעוד.
```python
def add(a: int, b: int) -> int:
    """
    Return the sum of two numbers.
    :param a: the first number
    :param b: the second number
    :return: the sum of both values
    """
    return a + b
```
זה לא סתם הערה.

פייתון ממש **שומרת** את ה-Docstring כחלק מהאובייקט עצמו.
```python
print(add.__doc__)
```
פלט:
```text
Returns the sum of the two numbers.
:param a: the first number
:param b: the second number
:return: the sum of both values

```

כלומר, זהו תיעוד חי, לא רק טקסט.  

**למה זה חשוב במערכות AI**  
במערכות AI יש עשרות פונקציות קטנות 
ניקוי, ניתוח, מדידה, ולוגים.
הן מתחברות אחת לשנייה כמו רכיבים במעגל חשמלי.
אם כל פונקציה מתועדת היטב,
אפשר להבין מה כל שלב עושה גם בלי לפתוח את הקוד הפנימי.
זה לא רק נוחות, זו **אחריות הנדסית**.
כשמישהו אחר (או אתה בעוד חודשיים) ניגש לקוד,
ה-Docstring הוא ההבדל בין “איך זה עובד?” לבין “מדהים, זה ברור!”.


**תקני תיעוד נפוצים**   

יש מספר סגנונות מקובלים. הנה שניים עיקריים:
1. **סגנון Google** 
```python
def load_dataset(path: str) -> list[str]:
    """
    Load a text file and return a list of lines.

    Args:
        path (str): the path to the file.

    Returns:
        list[str]: a list of lines from the file.
    """
```
2. **סגנון reStructuredText (בשימוש נרחב ב-Sphinx)**
```python
def load_dataset(path: str) -> list[str]:
    """
    Load a text file and return a list of lines.

    Args:
        path (str): the path to the file.

    Returns:
        list[str]: a list of lines from the file.
    """
    with open(path, "r", encoding="utf8") as f:
        return f.read().splitlines()
```
אין סגנון אחד "נכון" 
העיקר שתהיה עקביות בכל הפרויקט.  

**תיעוד גם לפונקציות פנימיות**  

גם פונקציות עזר קצרות ראויות ל-Docstring.
לא בגלל שמישהו אחר יקרא אותן,
אלא כדי לעזור לך להבין מה חשבת כשכתבת אותן.
```python
def normalize(text: str) -> str:
    """Remove extra spaces and convert to lowercase."""
    return text.strip().lower()
```
שורה אחת מספיקה כשאין מורכבות.  

**טיפ הנדסי**  
הכלל פשוט: “אם פונקציה שווה בשביל לכתוב אותה, היא שווה בשביל לתעד אותה.”
Docstrings אינם קישוט, הם חוזה.
הם מגדירים מה הפונקציה מבטיחה לעשות ומה לא.
וכשכותבים קוד שצריך לעבור ביקורת, תחזוקה, או עבודה בצוות 
זה ההבדל בין קוד “שנשבר” לקוד שחי שנים.

## Best Practices שמות, פיצול, אחריות יחידה
אחרי שהבנו איך פונקציות נוצרות, נקראות, מחזירות ערכים ומטפלות בפרמטרים 
נשארה השאלה החשובה באמת:
**איך לכתוב פונקציות שנשארות קריאות וברורות גם עוד חצי שנה?**  

**שמות: הפונקציה מדברת בעד עצמה**
שמות פונקציות טובים הם כמו תיעוד חכם 
אם אתה צריך לקרוא את ה-Docstring כדי להבין מה הפונקציה עושה,
כנראה שהשם שלה לא מספיק טוב.

**כללים פשוטים:**  

- שם פונקציה = **פועל** + תיאור הפעולה.
לדוגמה: load_data, clean_text, calculate_accuracy.
- לא לקצר מילים סתם: calc_acc אולי חוסך תווים, אבל גוזל קריאות.
- עדיף להיות ברור מאשר מתוחכם.
- אל תשתמש באותיות בודדות (כמו f, p או x) כשמות משתנים, אלא אם מדובר בהקשר מתמטי מובהק.  

שם טוב הוא חוזה: הוא מבטיח מה שהפונקציה עושה, ולא יותר.  

**פונקציה = פעולה אחת בלבד**   

אם פונקציה עושה יותר מדי, היא מאבדת את היכולת להיבדק, להבין ולתחזק.  

העיקרון הזה נקרא: **Single Responsibility Principle (SRP)** 
עיקרון הליבה של כל תכנות מודרני.
כל פונקציה צריכה:
1. לעשות דבר אחד בלבד.
2. לעשות אותו היטב.
3. להיקרא בהתאם למה שהיא עושה.
```python
def load_and_clean_data(path):  # does too much
    ...
```

עדיף:
```python
def load_data(path):
    ...
def clean_data(data):
    ...
```
זה אולי יותר שורות קוד, אבל הרבה פחות כאב ראש.

**פיצול חכם עדיף על אופטימיזציה מוקדמת**  

מתכנתים מנוסים נוטים “לדחוס” קוד כדי לשפר ביצועים.
אבל כמעט תמיד קריאות חשובה יותר ממהירות.
אם פונקציה נהיית ארוכה מדי, זה סימן שהיא צריכה להתפצל.
פייתון מעודדת קריאות על פני תחכום.
ולכן משפט אחד נכון שווה יותר מעשרה “טריקים פייתוניים”.

**פונקציות קצרות לא חייבות להיות טיפשיות** 

יש מי שחושב שפונקציות קצרות = פונקציות “לא שוות”.
בפועל, ההפך הוא הנכון:
פונקציות קטנות מאפשרות:
- בדיקות ממוקדות (unit tests) 
- שימוש חוזר בקוד
-  לוגים מדויקים
- וניטור מדויק של תקלות  

אין גבול תחתון לאורך פונקציה,
אבל כלל אצבע: אם צריך לגלול כדי להבין אותה, היא ארוכה מדי.  

**טיפ הנדסי**  
הבדל קטן בין מתכנת טוב למהנדס מצוין הוא **תחושת הסדר**.
מהנדס לא רק כותב קוד שעובד, אלא קוד שקל להבין, לבדוק ולשפר.
זכור את שלושת ה-S:
1. **:Simple** פשוט להבנה.
2. **:Specific** עושה דבר אחד ברור.
3. **:Self-describing** מדברת בעד עצמה.  

פונקציה טובה היא כמו משפט טוב, לא צריך להסביר אותה פעמיים.

## דוגמה מרכזית: utility functions לעיבוד טקסט
בפרויקטים של בינה מלאכותית, עיבוד טקסט הוא אחד השלבים הבסיסיים והנפוצים ביותר.
לפני שמודל לומד משהו, מישהו צריך לנקות את הנתונים, להפריד מילים, ולמדוד תוצאות.
במקום קוד מפוזר, נהוג לרכז פונקציות עזר (utilities) שמבצעות פעולות קטנות, עקביות וברורות.  

לצורך הדגמה נכתוב גרסה פשוטה של **text_utils.py**,
שתוכל להשתלב אחר כך בפרויקט ה-mini_text_analyzer שלך.    

**normalize  ניקוי בסיסי** 

```python
def normalize(text: str) -> str:
    """
    Clean text by removing extra spaces and converting to lowercase.
    """
    return text.strip().lower()
```
שורה אחת, אבל חשובה:
היא מבטיחה שכל שלב אחר יעבוד על נתונים עקביים.
גם מודלים מתקדמים ייכשלו אם הקלט לא יישר קו.  

**tokenize  פיצול למילים**
```python
import re

def tokenize(text: str) -> list[str]:
    """
    Split text into words while removing punctuation.
    """

    text = re.sub(r"[^\w\s-]", " ", text)  # keep hyphens
    return [w for w in text.split() if w]
```
זו דרך פשוטה ויעילה לבצע tokenization ראשוני לא מושלם כמו מודלי NLP, אבל מספיק לרוב התרחישים המוקדמים.
**word_stats  חישוב מדדים בסיסיים**
```python
from collections import Counter

def word_stats(words: list[str]) -> dict[str, int | str | float]:
    """
    Compute basic metrics for a list of words.
    """
    total = len(words)
    if total == 0:
        return {"num_words": 0, "avg_length": 0, "most_common": ""}
    avg_length = sum(len(w) for w in words) / total
    most_common = Counter(words).most_common(1)[0][0]
    return {
        "num_words": total,
        "avg_length": round(avg_length, 2),
        "most_common": most_common
    }
```

כאן אנחנו משלבים כמה עקרונות:
- פיצול אחריות: פונקציה אחת מחשבת, אחרת מנתחת.
- שימוש ב-Counter במקום כתיבת לולאה.
- החזרת מילון ברור עם שדות קבועים, נוח לכתיבה לקובץ או לוג. 

**analyze_text  הרכבה של מספר פונקציות**
```python
def analyze_text(text: str) -> dict[str, int | str | float]:
    """
    Run all analysis steps on raw text.
    """
    clean = normalize(text)
    words = tokenize(clean)
    return word_stats(words)
```
זו כבר פונקציה “על” שמדגימה **הרכבה נכונה של פונקציות קטנות**.
היא עושה דבר אחד בלבד 
קוראת לפונקציות אחרות במבנה ברור, בלי להתעסק בפרטים שלהן.

**דוגמת הרצה**
```python
if __name__ == "__main__":
    sample = "The AI of Python is amazing. Python is easy fast and convenient."
    print(analyze_text(sample))
```
פלט לדוגמה:
```python
{'num_words': 8, 'avg_length': 4.5, 'most_common': 'Python'}
```
  
**טיפ הנדסי**  
שים לב כמה הקוד קריא:
- כל פונקציה עושה פעולה אחת בלבד.
- השמות שלהן ברורים ומדברים בעד עצמם.
- אפשר לבדוק כל פונקציה בנפרד (unit test).
- והכול מתחבר לפונקציה אחת פשוטה: analyze_text.  

כך בונים **תשתית פונקציונלית אמינה**  
שאפשר להרחיב, לעטוף בלוגים, להוסיף מדידות,
ובסוף גם לשלב במערכת אמיתית לעיבוד שפה.

## סיכום: מה מתכנת מנוסה צריך לזכור
פונקציות הן הלב הפועם של פייתון.
הן לא רק מקצרות קוד, אלא **מייצרות ארכיטקטורה**.
כל פונקציה שאתה כותב היא לבנה קטנה במכונה גדולה 
וכשבונים נכון את הלבנים האלה, כל המערכת נראית אחרת לגמרי.

**עיקרי הדברים שחשוב לזכור!**  

**קלט ברור, פלט צפוי**  
פונקציה טובה מתנהגת כמו חוזה.
אם היא מקבלת ערכים, היא לא משנה אותם בחוץ.   
אם היא מחזירה ערכים, הם תמיד באותו מבנה.  

**אל תשתמש בערכי ברירת מחדל Mutable** 
זוהי אחת המלכודות הכי ותיקות בפייתון.
תמיד העדף None והתחל ערכים מחדש בתוך הפונקציה.  

**תעד הכל עם Docstrings** 
לא בשביל “הבודק”, אלא בשביל עצמך בעוד חצי שנה.
ה-Docstring הוא ההסבר שאתה כותב למי שיבוא אחריך, גם אם זה אתה.  

**פונקציה = פעולה אחת בלבד**
אם פונקציה עושה יותר מדבר אחד 
חלק אותה.
היא תישאר קריאה, נבדקת ונשלטת.  

**פונקציות הן אובייקטים**
תוכל להעביר אותן, לשמור אותן, וליצור מהן פונקציות חדשות.
זה כלי עוצמתי!  השתמש בו באחריות, לא מתוך גימיק.  

**קוד טוב הוא קוד פשוט**
אם אתה מתלבט אם לקצר או להשאיר קריאות.
תמיד בחר בקריאות.
מכונות קוראות מהר, אבל בני אדם מתחזקים קוד שנים.  

**סיכום תמציתי**
| עיקרון | מטרה |
| --- | --- |
| פשטות | קריאות והבנה מיידית |
| אחריות יחידה | תחזוקה ובדיקות קלות |
| תיעוד | שיתוף ידע ושימוש חוזר |
| חזרתיות נמוכה | פחות שגיאות |
| גמישות מבוקרת | הרחבה בלי לשבור |


**מילה אישית לסיום**  

במערכות AI, הפונקציות שלך הן ה-DNA של המערכת.
הן אלו שמחברות בין הנתונים, האלגוריתמים וההיגיון העסקי.
ככל שתכתוב פונקציות ברורות, קטנות ומתועדות היטב 
כך תוכל לגדול מהר יותר בלי לאבד שליטה. 
פונקציה טובה היא לא רק מה שרץ 
היא מה שאתה שמח לקרוא גם אחרי שנה.
